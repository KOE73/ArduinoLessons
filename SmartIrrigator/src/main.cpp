#include <Arduino.h>
#include <EEPROM.h>
#include <LittleFS.h>
#include <WiFi.h>

#include <Wire.h>

#include "nvs_flash.h"
#include "nvs.h"
#include "esp_log.h"

#include "config.h"
#include "data.h"
#include "webserver_me.h"
#include "ntp_time.h"

// Load data to LittleFS
// pio run --target uploadfs

static const char *TAG = "PUMP"; // —Ç–µ–≥ –¥–ª—è –º–æ–¥—É–ª—è

StateData CurrentState = {};
// –ß—Ç–æ–±—ã –≤–µ–±–∫–∞ –Ω–µ –º–æ—Ä–≥–∞–ª–∞
StateData WorkState;

void setupPins()
{
    pinMode(PIN_FILL_PUMP, OUTPUT);
    pinMode(PIN_IRR_PUMP, OUTPUT);
    pinMode(PIN_VALVE_1, OUTPUT);
    pinMode(PIN_VALVE_2, OUTPUT);
    pinMode(PIN_VALVE_3, OUTPUT);
    pinMode(PIN_FLOAT_SENSOR, INPUT);

    Wire.begin(PIN_SDA, PIN_SCL); // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è I2C —Å —É–∫–∞–∑–∞–Ω–∏–µ–º –ø–∏–Ω–æ–≤ SDA (20), SCL (21)
}

void stateIn(StateData &state)
{
    state.in_IsFull = digitalRead(PIN_FLOAT_SENSOR);
}

void stateOut(StateData &state)
{
    digitalWrite(PIN_FILL_PUMP, state.out_FillPumpOn);
    digitalWrite(PIN_IRR_PUMP, state.out_IrrigationPumpOn);
    digitalWrite(PIN_VALVE_1, state.out_ValveOn[0]);
    digitalWrite(PIN_VALVE_2, state.out_ValveOn[1]);
    digitalWrite(PIN_VALVE_3, state.out_ValveOn[2]);
}

// void controlFillPump()
//{
//     bool floatLow = digitalRead(PIN_FLOAT_SENSOR) == LOW;
//     bool anyValveActive = isValveScheduled(1) || isValveScheduled(2) || isValveScheduled(3);
//     bool canStart = (millis() - lastFillPumpOffTime) > FILL_PUMP_MIN_OFF_TIME * 1000;
//
//     if (floatLow && !anyValveActive && canStart)
//     {
//         digitalWrite(PIN_FILL_PUMP, HIGH);
//         fillPumpState = true;
//     }
//     else
//     {
//         if (fillPumpState)
//         {
//             fillPumpState = false;
//             lastFillPumpOffTime = millis();
//             saveLastFillPumpOffTime(lastFillPumpOffTime);
//         }
//         digitalWrite(PIN_FILL_PUMP, LOW);
//     }
// }

// void controlValvesAndIrrigationPump()
//{
//     bool pumpNeeded = false;
//
//     for (uint8_t i = 1; i <= 3; i++)
//     {
//         bool valveOn = getScheduleState(i);
//         digitalWrite(PIN_VALVE_1 + i - 1, valveOn ? HIGH : LOW);
//         if (valveOn)
//             pumpNeeded = true;
//     }
//
//     // –£—á–∏—Ç—ã–≤–∞–µ–º —Ä—É—á–Ω–æ–π —Ä–µ–∂–∏–º
//     if (isManualIrrigationActive())
//         pumpNeeded = true;
//
//     digitalWrite(PIN_IRR_PUMP, pumpNeeded ? HIGH : LOW);
// }

void listDir(fs::FS &fs, const char *dirname, uint8_t levels)
{
    ESP_LOGI(TAG, "üìÇ –°–æ–¥–µ—Ä–∂–∏–º–æ–µ –∫–∞—Ç–∞–ª–æ–≥–∞: %s", dirname);

    File root = fs.open(dirname);
    if (!root || !root.isDirectory())
    {
        ESP_LOGW(TAG, "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –∫–∞—Ç–∞–ª–æ–≥: %s", dirname);
        return;
    }

    File file = root.openNextFile();
    while (file)
    {
        if (file.isDirectory())
        {
            ESP_LOGI(TAG, "üìÅ [DIR]  %s", file.name());
            if (levels > 0)
            {
                listDir(fs, file.path(), levels - 1);
            }
        }
        else
        {
            ESP_LOGI(TAG, "üìÑ [FILE] %s  (%d –±–∞–π—Ç)", file.name(), file.size());
        }
        file = root.openNextFile();
    }
}

void listNVS()
{
    esp_err_t err = nvs_flash_init(); // –ú–æ–∂–Ω–æ —É–±—Ä–∞—Ç—å, –µ—Å–ª–∏ —É–∂–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω
    if (err != ESP_OK && err != ESP_ERR_NVS_NO_FREE_PAGES && err != ESP_ERR_NVS_NEW_VERSION_FOUND)
    {
        ESP_LOGE(TAG, "–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ NVS: %s", esp_err_to_name(err));
        return;
    }

    nvs_iterator_t it = nvs_entry_find(NVS_DEFAULT_PART_NAME, NULL, NVS_TYPE_ANY);
    if (it == nullptr)
    {
        ESP_LOGI(TAG, "NVS –ø—É—Å—Ç –∏–ª–∏ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–∞–Ω–Ω—ã—Ö.");
        return;
    }

    ESP_LOGI(TAG, "–°–æ–¥–µ—Ä–∂–∏–º–æ–µ NVS:");
    while (it != nullptr)
    {
        nvs_entry_info_t info;
        nvs_entry_info(it, &info);

        const char *typeStr = "UNKNOWN";
        switch (info.type)
        {
        case NVS_TYPE_U8:
            typeStr = "U8";
            break;
        case NVS_TYPE_I8:
            typeStr = "I8";
            break;
        case NVS_TYPE_U16:
            typeStr = "U16";
            break;
        case NVS_TYPE_I16:
            typeStr = "I16";
            break;
        case NVS_TYPE_U32:
            typeStr = "U32";
            break;
        case NVS_TYPE_I32:
            typeStr = "I32";
            break;
        case NVS_TYPE_U64:
            typeStr = "U64";
            break;
        case NVS_TYPE_I64:
            typeStr = "I64";
            break;
        case NVS_TYPE_STR:
            typeStr = "STRING";
            break;
        case NVS_TYPE_BLOB:
            typeStr = "BLOB";
            break;
        }

        ESP_LOGI(TAG, "Namespace: %-15s Key: %-15s Type: %s", info.namespace_name, info.key, typeStr);

        it = nvs_entry_next(it);
    }

    ESP_LOGI(TAG, "–ö–æ–Ω–µ—Ü —Å–ø–∏—Å–∫–∞.");
}

void listNVS2()
{
    esp_err_t err = nvs_flash_init(); // –ú–æ–∂–Ω–æ —É–±—Ä–∞—Ç—å, –µ—Å–ª–∏ —É–∂–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω
    if (err != ESP_OK && err != ESP_ERR_NVS_NO_FREE_PAGES && err != ESP_ERR_NVS_NEW_VERSION_FOUND)
    {
        ESP_LOGE(TAG, "–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ NVS: %s", esp_err_to_name(err));
        return;
    }

    nvs_iterator_t it = nvs_entry_find(NVS_DEFAULT_PART_NAME, NULL, NVS_TYPE_ANY);
    if (it == nullptr)
    {
        ESP_LOGI(TAG, "NVS –ø—É—Å—Ç –∏–ª–∏ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–∞–Ω–Ω—ã—Ö.");
        return;
    }

    ESP_LOGI(TAG, "–°–æ–¥–µ—Ä–∂–∏–º–æ–µ NVS:");

    while (it != nullptr)
    {
        nvs_entry_info_t info;
        nvs_entry_info(it, &info);
        const char *typeStr = "UNKNOWN";
        String valueStr = "?";

        // –û—Ç–∫—Ä—ã–≤–∞–µ–º namespace –¥–ª—è —á—Ç–µ–Ω–∏—è
        nvs_handle_t handle;
        if (nvs_open(info.namespace_name, NVS_READONLY, &handle) != ESP_OK)
        {
            ESP_LOGW(TAG, "–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å namespace %s", info.namespace_name);
            it = nvs_entry_next(it);
            continue;
        }

        // –ü—ã—Ç–∞–µ–º—Å—è —Å—á–∏—Ç–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ
        if (info.type == NVS_TYPE_I32)
        {
            int32_t val = 0;
            if (nvs_get_i32(handle, info.key, &val) == ESP_OK)
                valueStr = String(val);
            typeStr = "I32";
        }
        else if (info.type == NVS_TYPE_U32)
        {
            uint32_t val = 0;
            if (nvs_get_u32(handle, info.key, &val) == ESP_OK)
                valueStr = String(val);
            typeStr = "U32";
        }
        else if (info.type == NVS_TYPE_STR)
        {
            size_t len = 0;
            if (nvs_get_str(handle, info.key, NULL, &len) == ESP_OK && len > 0)
            {
                char *buf = (char *)malloc(len);
                if (nvs_get_str(handle, info.key, buf, &len) == ESP_OK)
                    valueStr = String(buf);
                free(buf);
            }
            typeStr = "STR";
        }
        else if (info.type == NVS_TYPE_U8)
        {
            uint8_t val = 0;
            if (nvs_get_u8(handle, info.key, &val) == ESP_OK)
                valueStr = String(val);
            typeStr = "U8";
        }
        else if (info.type == NVS_TYPE_BLOB)
        {
            size_t len = 0;
            if (nvs_get_blob(handle, info.key, NULL, &len) == ESP_OK && len > 0)
            {
                valueStr = "<BLOB, " + String(len) + " –±–∞–π—Ç>";
            }
            typeStr = "BLOB";
        }

        ESP_LOGI(TAG, "Namespace: %-12s  Key: %-16s  Type: %-6s  Value: %s",
                 info.namespace_name, info.key, typeStr, valueStr.c_str());

        nvs_close(handle);
        it = nvs_entry_next(it);
    }

    ESP_LOGI(TAG, "–ö–æ–Ω–µ—Ü —Å–ø–∏—Å–∫–∞.");
}

void setup()
{
    // pinMode(LED_BUILTIN, OUTPUT);
    pinMode(8, OUTPUT);
    digitalWrite(8, LOW);
    delay(2000);
    digitalWrite(8, HIGH);

    Serial.begin(921600);
    Serial.println("BOOT"); // –¥–æ–ª–∂–Ω–æ —Å—Ä–∞–∑—É –ø–æ–∫–∞–∑–∞—Ç—å —á—Ç–æ-—Ç–æ
    printf("SETUP x\n");

    ESP_LOGI(TAG, "SETUP");

    setupPins();
    EEPROM.begin(EEPROM_SIZE);

    if (!LittleFS.begin(true, "/littlefs", 10, "littlefs"))
    {
        ESP_LOGE(TAG, "LittleFS –º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å");
        return;
    }

    listDir(LittleFS, "/", 1);

    File file = LittleFS.open("/index.html", "r");
    if (!file)
    {
        ESP_LOGE(TAG, "–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω");
        return;
    }

    setupWiFi();
    setupWebServer();
    initTime();

    //    // ---- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ CurrentState
    //    // –ï—Å–ª–∏ —ç—Ç–æ –ø–µ—Ä–≤—ã–π –∑–∞–ø—É—Å–∫, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –±–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, —á—Ç–æ–±—ã –Ω–∞—Å–æ—Å –º–æ–∂–Ω–æ –±—ã–ª–æ –≤–∫–ª—é—á–∞—Ç—å
    //    if (CurrentState.out_FillPumpOn_LastOffTime == 0)
    //    {
    //        CurrentState.out_FillPumpOn_LastOffTime = millis() - FILL_PUMP_MIN_OFF_TIME_MS - 1;
    //    }

    // üïí –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç–∞–π–º–µ—Ä–æ–≤
    CurrentState.timer_Fill_RestartBlock.PT_presetTime = FILL_PUMP_MIN_OFF_TIME_MS;
    CurrentState.timer_Fill_MaxRuntime.PT_presetTime = FILL_PUMP_MAX_RUNTIME_MS;
    CurrentState.timer_IsFull_Confirm.PT_presetTime = FULL_STABLE_TIME_MS;

    loadSchedulesFromNVS();
    loadSetupDataFromNVS();
    CurrentState.applySetupDataToTimers();

    // https://github.com/nayarsystems/posix_tz_db/blob/master/zones.json
    // setenv("TZ", "Asia/Yekaterinburg", 1);  // –í–ê–ñ–ù–û: –º–∏–Ω—É—Å, –ø–æ—Ç–æ–º—É —á—Ç–æ –≤ TZ –ø—Ä–∞–≤–∏–ª–∞—Ö –æ–±—Ä–∞—Ç–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
    setenv("TZ", "YEKT-5", 1); // –í–ê–ñ–ù–û: –º–∏–Ω—É—Å, –ø–æ—Ç–æ–º—É —á—Ç–æ –≤ TZ –ø—Ä–∞–≤–∏–ª–∞—Ö –æ–±—Ä–∞—Ç–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
    tzset();

    // listNVS2();
}

void loop()
{
    auto nowMilis = millis();
    if (nowMilis % 1000 < 500)
        digitalWrite(8, LOW); // turn the LED off by making the voltage LOW
    else
        digitalWrite(8, HIGH); // turn the LED on (HIGH is the voltage level)

    if (nowMilis % 5000 == 0)
        ESP_LOGI(TAG, "Connected! IP: %s", WiFi.localIP().toString().c_str());

#pragma region Input
    // –°—á–∏—Ç—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è –≤—Ö–æ–¥–æ–≤
    stateIn(CurrentState);
#pragma endregion Input

    // –û–±–Ω—É–ª–µ–Ω–∏–µ –≤—ã—Ö–æ–¥–æ–≤, –ø–æ—Å–ª–µ–¥—É—é—â–∞—è –ª–æ–≥–∏–∫–∞, –µ—Å–ª–∏ –Ω–∞–¥–æ –≤–∫–ª—é—á–∏—Ç –æ–±—Ä–∞—Ç–Ω–æ
    CurrentState.out_FillPumpOn = false;
    CurrentState.out_IrrigationPumpOn = false;
    CurrentState.allValvesOff();

#pragma region –í—Ä–µ–º—è
    // –ü–æ–ª—É—á–∞–µ–º –≤—Ä–µ–º—è, –±—ã–≤–∞–µ—Ç —á—Ç–æ –Ω–µ –ø–æ–ª—É—á–∞–µ—Ç—Å—è ! :-/
    tm timeInfo;
    CurrentState.hasTime = getLocalTime(&timeInfo, 100);

    CurrentState.hasNTP = sntpReady();
    CurrentState.hasRTC = rtcHasRTC();
    CurrentState.hasTimeRTC = rtcHasTime();
    CurrentState.rtcLostPower = rtcLostPower();
    CurrentState.rtcTemperature = rtcGetTemperature();
    getRTCTime(CurrentState.rtcTimeInfo);

    // –ï—Å–ª–∏ –≤—Ä–µ–º–µ–Ω–∏ –Ω–µ—Ç, —Ç–æ –≤—Å—ë –≤—ã–∫–ª—é—á–∞–µ–º –∏ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –æ—Å–Ω–æ–≤–Ω—É—é –ª–æ–≥–∏–∫—É
    if (!CurrentState.hasTime)
        goto endMainLogik;

    CurrentState.now = mktime(&timeInfo);
    CurrentState.nowTimeInfo = timeInfo;
    CurrentState.minutesSinceMidnight = getMinutesSinceMidnight(timeInfo);

#pragma endregion

#pragma region –†—É—á–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
Manual:
    // –ï—Å–ª–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ –≤—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è —Ä—É—á–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è, —Ç–æ —á—Ç–æ-—Ç–æ —Ö–æ–∑—è–∏–Ω –≤–∫–ª—é—á–∏–ª, –Ω–µ –±—É–¥–µ–º –µ–º—É –º–µ—à–∞—Ç—å
    if (CurrentState.in_TimeManualOff != 0)
    {
        // –ï—Å–ª–∏ —Ä—É—á–Ω–æ–µ –≤—ã–∫–ª—é—á–µ–Ω–æ –∏–ª–∏
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Ä–µ–º—è –∏ –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—Å–µ —Ä—É—á–Ω—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –µ—Å–ª–∏ –≤—Ä–µ–º—è –ø–æ–¥–æ—à–ª–æ
        if (!CurrentState.anyManuals() ||CurrentState.now >= CurrentState.in_TimeManualOff)
            CurrentState.allManualsOff();

        CurrentState.out_FillPumpOn = CurrentState.in_IsManualFill;
        CurrentState.out_IrrigationPumpOn = CurrentState.in_IsManualIrrigation;
        std::copy(std::begin(CurrentState.in_IsManualValveOn), std::end(CurrentState.in_IsManualValveOn), std::begin(CurrentState.out_ValveOn));

        // –ü—Ä–æ–ø—É—Å–∫–∞–º —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∏–±–æ –Ω–µ—Ñ–º–≥ –ø–æ–ø–µ—Ä–µ–∫ –±–∞—Ç—å–∫–∏
        goto endMainLogik;
    }
#pragma endregion

#pragma region –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ
Shedule:
    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ
    for (auto &shedule : CurrentState.shedules)
    {
        if (shedule.isTimeInRange(CurrentState.minutesSinceMidnight))
        {
            std::copy(
                std::begin(shedule.valves),
                std::end(shedule.valves),
                std::begin(CurrentState.out_ValveOn));
            CurrentState.out_IrrigationPumpOn = shedule.irrigationPump;
            CurrentState.out_FillPumpOn = shedule.fillPump;
        }
    }
#pragma endregion

endMainLogik:

    // –ê–ª—è LAD
    // 1. –ï—Å–ª–∏ –∏–¥—ë—Ç –ø–æ–ª–∏–≤ –∏–ª–∏ –æ—Ç–∫—Ä—ã—Ç—ã –∫–ª–∞–ø–∞–Ω—ã ‚Äî –Ω–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–ø—Ä–µ—â–µ–Ω–æ
    if (CurrentState.out_IrrigationPumpOn || CurrentState.anyValveOn())
    {
        CurrentState.out_FillPumpOn = false;
    }

    // 2. –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Å—Ç–∞–±–∏–ª—å–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è –ø–æ–ø–ª–∞–≤–∫–∞ —á–µ—Ä–µ–∑ —Ç–∞–π–º–µ—Ä
    CurrentState.timer_IsFull_Confirm.update(CurrentState.in_IsFull, nowMilis);
    bool prevConfirmed = CurrentState.in_IsFull_Confirmed;
    CurrentState.in_IsFull_Confirmed = CurrentState.timer_IsFull_Confirm.Q_output;

    // 6. –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–º—É –≤—Ä–µ–º–µ–Ω–∏ —Ä–∞–±–æ—Ç—ã
    CurrentState.timer_Fill_MaxRuntime.update(CurrentState.out_FillPumpOn, nowMilis);

    // 3. –ï—Å–ª–∏ —É—Ä–æ–≤–µ–Ω—å –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–ª—Å—è –∏–ª–∏ –≤—ã—à–ª–æ –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã ‚Äî —Å–±—Ä–æ—Å —Ä—É—á–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞ // ???, –∑–∞–ø—É—Å–∫ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
    if ((CurrentState.in_IsFull_Confirmed) || CurrentState.timer_Fill_MaxRuntime.Q_output)
    {
        CurrentState.in_IsManualFill = false;
        CurrentState.out_FillPumpOn = false;

        // **** CurrentState.timer_Fill_RestartBlock.update(true, nowMilis);
        ESP_LOGI("LEVEL", "–ë–æ—á–∫–∞ –ø–æ–ª–Ω–∞—è %s, —Ç–∞–π–º–µ—Ä %s",
                 BOOL_STR(CurrentState.in_IsFull_Confirmed),
                 BOOL_STR(CurrentState.timer_Fill_MaxRuntime.Q_output));
    }

    // 4. –ü—Ä–∏ –ø–∞–¥–µ–Ω–∏–∏ —É—Ä–æ–≤–Ω—è ‚Äî –ª–æ–≥
    if (!CurrentState.in_IsFull_Confirmed && prevConfirmed)
    {
        ESP_LOGI("LEVEL", "‚¨áÔ∏è –£—Ä–æ–≤–µ–Ω—å —É–ø–∞–ª ‚Äî —Å–±—Ä–æ—Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è");
    }

    //// 5. –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞
    // CurrentState.timer_Fill_RestartBlock.update(!CurrentState.out_FillPumpOn, nowMilis);
    // if (CurrentState.timer_Fill_RestartBlock.Q_output)
    //{
    //     CurrentState.out_FillPumpOn = false;
    // }

endLogik:
    // –í—ã–≤–æ–¥–∏–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤—ã—Ö–æ–¥–æ–≤
    stateOut(CurrentState);

    // –ü–æ–ª–Ω–∞—è –∫–æ–ø–∏—è –¥–ª—è –≤–µ–±–∫–∏, –∞ —Ç–æ –Ω–∞–∫–ª–∞–¥–∫–∏ —Å–ª—É—á–∞—é—Ç—Å—è
    WorkState = CurrentState;
}
